{
  contract_id: 30898,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:16.055Z'
}
{
  contract_id: 30899,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:16.066Z'
}
{
  contract_id: 30897,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:16.071Z'
}
{
  contract_id: 30896,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:16.077Z'
}
{
  contract_id: 30900,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:16.084Z'
}
{
  contract_id: 30901,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:17.045Z'
}
{
  contract_id: 30902,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:21.536Z'
}
{
  contract_id: 30903,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:21.542Z'
}
{
  contract_id: 30904,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:21.606Z'
}
{
  contract_id: 30905,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:21.619Z'
}
{
  contract_id: 30906,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:21.627Z'
}
{
  contract_id: 30907,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:22.342Z'
}
{
  contract_id: 30908,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:22.713Z'
}
{
  contract_id: 30909,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:22.861Z'
}
{
  contract_id: 30910,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:26.959Z'
}
{
  contract_id: 30911,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:26.967Z'
}
{
  contract_id: 30912,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:26.980Z'
}
{
  contract_id: 30913,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:27.004Z'
}
{
  contract_id: 30914,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:27.248Z'
}
{
  contract_id: 30915,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:27.990Z'
}
{
  contract_id: 30916,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:27.993Z'
}
{
  contract_id: 30917,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:28.250Z'
}
{
  contract_id: 30918,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:28.263Z'
}
{
  contract_id: 30919,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:28.513Z'
}
{
  contract_id: 30920,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:32.842Z'
}
{
  contract_id: 30921,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:32.850Z'
}
{
  contract_id: 30922,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:32.865Z'
}
{
  contract_id: 30923,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:33.067Z'
}
{
  contract_id: 30924,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:33.446Z'
}
{
  contract_id: 30925,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:33.453Z'
}
{
  contract_id: 30926,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:33.465Z'
}
{
  contract_id: 30927,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:34.024Z'
}
{
  contract_id: 30928,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:34.053Z'
}
{
  contract_id: 30929,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:34.328Z'
}
{
  contract_id: 30930,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:34.976Z'
}
{
  contract_id: 30931,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:38.776Z'
}
{
  contract_id: 30932,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:38.782Z'
}
{
  contract_id: 30933,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:38.811Z'
}
{
  contract_id: 30934,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:38.819Z'
}
{
  contract_id: 30935,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:39.032Z'
}
{
  contract_id: 30936,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:39.765Z'
}
{
  contract_id: 30937,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:39.974Z'
}
{
  contract_id: 30938,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:39.977Z'
}
{
  contract_id: 30939,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:40.104Z'
}
{
  contract_id: 30940,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:40.145Z'
}
{
  contract_id: 30941,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:43.969Z'
}
{
  contract_id: 30942,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:43.976Z'
}
{
  contract_id: 30944,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:43.982Z'
}
{
  contract_id: 30943,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:43.987Z'
}
{
  contract_id: 30945,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:44.297Z'
}
{
  contract_id: 30946,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:44.547Z'
}
{
  contract_id: 30947,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:44.979Z'
}
{
  contract_id: 30948,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:44.993Z'
}
{
  contract_id: 30949,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:45.006Z'
}
{
  contract_id: 30950,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:45.268Z'
}
{
  contract_id: 30951,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:46.552Z'
}
{
  contract_id: 30952,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:50.352Z'
}
{
  contract_id: 30953,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:50.357Z'
}
{
  contract_id: 30954,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:50.361Z'
}
{
  contract_id: 30955,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:50.384Z'
}
{
  contract_id: 30956,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:11:50.390Z'
}
{
  contract_id: 30957,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:53.071Z'
}
{
  contract_id: 30958,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:53.082Z'
}
{
  contract_id: 30959,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:53.088Z'
}
{
  contract_id: 30960,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:53.119Z'
}
{
  contract_id: 30961,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:53.142Z'
}
{
  contract_id: 30962,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:54.431Z'
}
{
  contract_id: 30963,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.275Z'
}
{
  contract_id: 30964,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.293Z'
}
{
  contract_id: 30965,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.299Z'
}
{
  contract_id: 30966,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.308Z'
}
{
  contract_id: 30967,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.313Z'
}
{
  contract_id: 30968,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:15:58.800Z'
}
{
  contract_id: 30969,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:03.849Z'
}
{
  contract_id: 30970,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:03.857Z'
}
{
  contract_id: 30971,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:03.862Z'
}
{
  contract_id: 30972,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:03.867Z'
}
{
  contract_id: 30973,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:03.872Z'
}
{
  contract_id: 30974,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:04.635Z'
}
{
  contract_id: 30975,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:04.900Z'
}
{
  contract_id: 30976,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:04.904Z'
}
{
  contract_id: 30977,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:04.968Z'
}
{
  contract_id: 30978,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:04.996Z'
}
{
  contract_id: 30979,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:08.687Z'
}
{
  contract_id: 30980,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:08.708Z'
}
{
  contract_id: 30981,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:08.714Z'
}
{
  contract_id: 30982,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:08.730Z'
}
{
  contract_id: 30983,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:08.745Z'
}
{
  contract_id: 30984,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:09.755Z'
}
{
  contract_id: 30985,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:09.788Z'
}
{
  contract_id: 30986,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:13.526Z'
}
{
  contract_id: 30987,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:13.539Z'
}
{
  contract_id: 30988,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:13.544Z'
}
{
  contract_id: 30989,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:13.574Z'
}
{
  contract_id: 30990,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:13.576Z'
}
{
  contract_id: 30991,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:14.662Z'
}
{
  contract_id: 30992,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:19.333Z'
}
{
  contract_id: 30993,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:19.341Z'
}
{
  contract_id: 30994,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:19.870Z'
}
{
  contract_id: 30995,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:19.876Z'
}
{
  contract_id: 30996,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.079Z'
}
{
  contract_id: 30997,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.438Z'
}
{
  contract_id: 30999,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.449Z'
}
{
  contract_id: 30998,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.454Z'
}
{
  contract_id: 31000,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.460Z'
}
{
  contract_id: 31001,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:20.510Z'
}
{
  contract_id: 31002,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:21.407Z'
}
{
  contract_id: 31003,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:26.751Z'
}
{
  contract_id: 31004,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.483Z'
}
{
  contract_id: 31005,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.533Z'
}
{
  contract_id: 31006,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.593Z'
}
{
  contract_id: 31007,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.629Z'
}
{
  contract_id: 31008,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.781Z'
}
{
  contract_id: 31009,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.817Z'
}
{
  contract_id: 31010,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.824Z'
}
{
  contract_id: 31011,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.837Z'
}
{
  contract_id: 31012,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:16:27.900Z'
}
{
  contract_id: 31013,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:10.312Z'
}
{
  contract_id: 31014,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:10.317Z'
}
{
  contract_id: 31015,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:10.330Z'
}
{
  contract_id: 31016,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:10.333Z'
}
{
  contract_id: 31017,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:10.339Z'
}
{
  contract_id: 31018,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:12.295Z'
}
{
  contract_id: 31019,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:12.737Z'
}
{
  contract_id: 31020,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:15.819Z'
}
{
  contract_id: 31021,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:15.839Z'
}
{
  contract_id: 31023,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:15.844Z'
}
{
  contract_id: 31022,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:15.852Z'
}
{
  contract_id: 31024,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:16.845Z'
}
{
  contract_id: 31025,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:16.992Z'
}
{
  contract_id: 31026,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:20.938Z'
}
{
  contract_id: 31027,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:20.943Z'
}
{
  contract_id: 31028,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:20.950Z'
}
{
  contract_id: 31029,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:20.975Z'
}
{
  contract_id: 31030,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:21.523Z'
}
{
  contract_id: 31031,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:22.799Z'
}
{
  contract_id: 31032,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:25.546Z'
}
{
  contract_id: 31033,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:25.561Z'
}
{
  contract_id: 31034,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:25.574Z'
}
{
  contract_id: 31035,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:25.582Z'
}
{
  contract_id: 31036,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:26.606Z'
}
{
  contract_id: 31037,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:26.962Z'
}
{
  contract_id: 31038,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:27.505Z'
}
{
  contract_id: 31039,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:30.532Z'
}
{
  contract_id: 31041,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:30.546Z'
}
{
  contract_id: 31042,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:30.550Z'
}
{
  contract_id: 31040,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:30.555Z'
}
{
  contract_id: 31043,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:31.599Z'
}
{
  contract_id: 31044,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:33.536Z'
}
{
  contract_id: 31045,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:35.148Z'
}
{
  contract_id: 31046,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:35.156Z'
}
{
  contract_id: 31047,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:35.160Z'
}
{
  contract_id: 31048,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:35.406Z'
}
{
  contract_id: 31049,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:36.192Z'
}
{
  contract_id: 31050,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:36.328Z'
}
{
  contract_id: 31051,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:39.949Z'
}
{
  contract_id: 31052,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:39.997Z'
}
{
  contract_id: 31053,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:19:40.224Z'
}
{
  contract_id: 31054,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:03.798Z'
}
{
  contract_id: 31055,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:04.034Z'
}
{
  contract_id: 31056,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:04.264Z'
}
{
  contract_id: 31057,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:05.034Z'
}
{
  contract_id: 31058,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:05.343Z'
}
{
  contract_id: 31059,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:05.350Z'
}
{
  contract_id: 31060,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:05.630Z'
}
{
  contract_id: 31061,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:07.577Z'
}
{
  contract_id: 31062,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:07.873Z'
}
{
  contract_id: 31063,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:07.981Z'
}
{
  contract_id: 31064,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:08.091Z'
}
{
  contract_id: 31065,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:08.252Z'
}
{
  contract_id: 31066,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:08.653Z'
}
{
  contract_id: 31067,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:08.737Z'
}
{
  contract_id: 31068,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:08.983Z'
}
{
  contract_id: 31069,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:09.078Z'
}
{
  contract_id: 31070,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:09.336Z'
}
{
  contract_id: 31071,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:09.814Z'
}
{
  contract_id: 31072,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:09.979Z'
}
{
  contract_id: 31073,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:11.339Z'
}
{
  contract_id: 31074,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:13.357Z'
}
{
  contract_id: 31075,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:13.364Z'
}
{
  contract_id: 31076,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:13.826Z'
}
{
  contract_id: 31077,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:14.453Z'
}
{
  contract_id: 31078,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:14.542Z'
}
{
  contract_id: 31079,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:14.580Z'
}
{
  contract_id: 31080,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:15.183Z'
}
{
  contract_id: 31081,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:15.618Z'
}
{
  contract_id: 31082,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:18.715Z'
}
{
  contract_id: 31083,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:19.356Z'
}
{
  contract_id: 31084,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:19.362Z'
}
{
  contract_id: 31085,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:19.562Z'
}
{
  contract_id: 31086,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:20.354Z'
}
{
  contract_id: 31087,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:20.360Z'
}
{
  contract_id: 31088,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:20.365Z'
}
{
  contract_id: 31089,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:20.370Z'
}
{
  contract_id: 31090,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:20.828Z'
}
{
  contract_id: 31091,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:21.551Z'
}
{
  contract_id: 31092,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:21.857Z'
}
{
  contract_id: 31093,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:24.580Z'
}
{
  contract_id: 31094,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:24.585Z'
}
{
  contract_id: 31095,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:26.140Z'
}
{
  contract_id: 31096,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:26.728Z'
}
{
  contract_id: 31097,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:26.967Z'
}
{
  contract_id: 31098,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:27.344Z'
}
{
  contract_id: 31099,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:29.568Z'
}
{
  contract_id: 31100,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:29.577Z'
}
{
  contract_id: 31101,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:30.669Z'
}
{
  contract_id: 31102,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:32.096Z'
}
{
  contract_id: 31103,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:32.763Z'
}
{
  contract_id: 31104,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:33.357Z'
}
{
  contract_id: 31105,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:34.379Z'
}
{
  contract_id: 31106,
  address: '0xd90e2f925DA726b50C4Ed8D0Fb90Ad053324F31b',
  source_code: '{{\r\n' +
    '  "language": "Solidity",\r\n' +
    '  "sources": {\r\n' +
    '    "contracts/tornado-proxy/TornadoRouter.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport \\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\";\\nimport \\"@openzeppelin/contracts/math/Math.sol\\";\\nimport \\"tornado-anonymity-mining/contracts/interfaces/ITornadoInstance.sol\\";\\nimport \\"torn-token/contracts/ENS.sol\\";\\nimport \\"./InstanceRegistry.sol\\";\\nimport \\"../RelayerRegistry.sol\\";\\n\\ncontract TornadoRouter is EnsResolve {\\n  using SafeERC20 for IERC20;\\n\\n  event EncryptedNote(address indexed sender, bytes encryptedNote);\\n\\n  address public immutable governance;\\n  InstanceRegistry public immutable instanceRegistry;\\n  RelayerRegistry public immutable relayerRegistry;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\"Not authorized\\");\\n    _;\\n  }\\n\\n  modifier onlyInstanceRegistry() {\\n    require(msg.sender == address(instanceRegistry), \\"Not authorized\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    bytes32 _instanceRegistry,\\n    bytes32 _relayerRegistry\\n  ) public {\\n    governance = _governance;\\n    instanceRegistry = InstanceRegistry(resolve(_instanceRegistry));\\n    relayerRegistry = RelayerRegistry(resolve(_relayerRegistry));\\n  }\\n\\n  function deposit(\\n    ITornadoInstance _tornado,\\n    bytes32 _commitment,\\n    bytes calldata _encryptedNote\\n  ) public payable virtual {\\n    (bool isERC20, IERC20 token, InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n\\n    if (isERC20) {\\n      token.safeTransferFrom(msg.sender, address(this), _tornado.denomination());\\n    }\\n    _tornado.deposit{ value: msg.value }(_commitment);\\n    emit EncryptedNote(msg.sender, _encryptedNote);\\n  }\\n\\n  function withdraw(\\n    ITornadoInstance _tornado,\\n    bytes calldata _proof,\\n    bytes32 _root,\\n    bytes32 _nullifierHash,\\n    address payable _recipient,\\n    address payable _relayer,\\n    uint256 _fee,\\n    uint256 _refund\\n  ) public payable virtual {\\n    (, , InstanceRegistry.InstanceState state, , ) = instanceRegistry.instances(_tornado);\\n    require(state != InstanceRegistry.InstanceState.DISABLED, \\"The instance is not supported\\");\\n    relayerRegistry.burn(msg.sender, _relayer, _tornado);\\n\\n    _tornado.withdraw{ value: msg.value }(_proof, _root, _nullifierHash, _recipient, _relayer, _fee, _refund);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` allowance of `_spender` over the router\'s (this contract) tokens.\\n   */\\n  function approveExactToken(\\n    IERC20 _token,\\n    address _spender,\\n    uint256 _amount\\n  ) external onlyInstanceRegistry {\\n    _token.safeApprove(_spender, _amount);\\n  }\\n\\n  /**\\n   * @notice Manually backup encrypted notes\\n   */\\n  function backupNotes(bytes[] calldata _encryptedNotes) external virtual {\\n    for (uint256 i = 0; i < _encryptedNotes.length; i++) {\\n      emit EncryptedNote(msg.sender, _encryptedNotes[i]);\\n    }\\n  }\\n\\n  /// @dev Method to claim junk and accidentally sent tokens\\n  function rescueTokens(\\n    IERC20 _token,\\n    address payable _to,\\n    uint256 _amount\\n  ) external virtual onlyGovernance {\\n    require(_to != address(0), \\"TORN: can not send to zero address\\");\\n\\n    if (_token == IERC20(0)) {\\n      // for Ether\\n      uint256 totalBalance = address(this).balance;\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      _to.transfer(balance);\\n    } else {\\n      // any other erc20\\n      uint256 totalBalance = _token.balanceOf(address(this));\\n      uint256 balance = Math.min(totalBalance, _amount);\\n      require(balance > 0, \\"TORN: trying to send 0 balance\\");\\n      _token.safeTransfer(_to, balance);\\n    }\\n  }\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n"\r\n' +
    '    },\r\n' +
    '    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {\r\n' +
    '      "content": "// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\"./IERC20.sol\\";\\nimport \\"../../math/SafeMath.sol\\";\\nimport \\"../../utils/Address.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\"SafeERC20: approve from non-zero to non-zero allowance\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\"SafeERC20: decreased allowance below zero\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        /'... 134918 more characters,
  is_verified: true,
  type: 'ERC20',
  chain_hash: '0x1',
  name_tag: 'Tornado.Cash',
  label_source: 'ethereum',
  logo: 'https://entities-logos.s3.us-east-1.amazonaws.com/tornadocash.png',
  abi: '[{"inputs":[{"internalType":"address","name":"_governance","type":"address"},{"internalType":"bytes32","name":"_instanceRegistry","type":"bytes32"},{"internalType":"bytes32","name":"_relayerRegistry","type":"bytes32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"encryptedNote","type":"bytes"}],"name":"EncryptedNote","type":"event"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"approveExactToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"_encryptedNotes","type":"bytes[]"}],"name":"backupNotes","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"domains","type":"bytes32[]"}],"name":"bulkResolve","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes32","name":"_commitment","type":"bytes32"},{"internalType":"bytes","name":"_encryptedNote","type":"bytes"}],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"governance","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"instanceRegistry","outputs":[{"internalType":"contract InstanceRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"relayerRegistry","outputs":[{"internalType":"contract RelayerRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"_token","type":"address"},{"internalType":"address payable","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"rescueTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ITornadoInstance","name":"_tornado","type":"address"},{"internalType":"bytes","name":"_proof","type":"bytes"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes32","name":"_nullifierHash","type":"bytes32"},{"internalType":"address payable","name":"_recipient","type":"address"},{"internalType":"address payable","name":"_relayer","type":"address"},{"internalType":"uint256","name":"_fee","type":"uint256"},{"internalType":"uint256","name":"_refund","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]',
  level: 'info',
  message: 'Contract created: ',
  label: 'backend',
  timestamp: '2025-01-26T04:21:34.384Z'
}
